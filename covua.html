<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game C·ªù Vua</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 600px;
            width: 100%;
        }

        .title {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 28px;
            font-weight: bold;
        }

        .mode-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            min-width: 120px;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .mode-btn:not(.active) {
            background: #f0f0f0;
            color: #333;
        }

        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .chessboard {
            width: 100%;
            max-width: 480px;
            aspect-ratio: 1;
            margin: 0 auto 20px;
            border: 3px solid #333;
            border-radius: 10px;
            overflow: hidden;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
        }

        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(20px, 4vw, 32px);
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            user-select: none;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #ffeb3b !important;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }

        .square.possible-move {
            background-color: #4caf50 !important;
        }

        .square.under-attack {
            background-color: #f44336 !important;
        }

        .square:hover {
            opacity: 0.8;
        }

        .piece {
            font-size: inherit;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            background: #667eea;
            color: white;
        }

        .control-btn:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }

        .status {
            text-align: center;
            margin: 15px 0;
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .difficulty-selector {
            margin: 10px 0;
            text-align: center;
        }

        .difficulty-selector select {
            padding: 8px;
            border-radius: 5px;
            border: 2px solid #ddd;
            font-size: 16px;
        }

        @media (max-width: 600px) {
            .game-container {
                padding: 15px;
            }
            
            .title {
                font-size: 24px;
            }
            
            .game-modes {
                flex-direction: column;
            }
            
            .mode-btn {
                min-width: auto;
            }
            
            .controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 class="title">üèÜ Game C·ªù Vua</h1>
        
        <div class="game-modes">
            <button class="mode-btn active" onclick="setGameMode('vs-human')">üë• Ch∆°i v·ªõi Ng∆∞·ªùi</button>
            <button class="mode-btn" onclick="setGameMode('vs-ai')">ü§ñ Ch∆°i v·ªõi M√°y</button>
        </div>

        <div class="difficulty-selector" id="difficultySelector" style="display: none;">
            <label for="difficulty">ƒê·ªô kh√≥: </label>
            <select id="difficulty" onchange="setDifficulty()">
                <option value="1">D·ªÖ</option>
                <option value="2" selected>Trung b√¨nh</option>
                <option value="3">Kh√≥</option>
            </select>
        </div>



        <div class="status" id="gameStatus">L∆∞·ª£t c·ªßa qu√¢n Tr·∫Øng</div>

        <div class="chessboard" id="chessboard"></div>

        <div class="controls">
            <button class="control-btn" onclick="newGame()">üÜï Game M·ªõi</button>
            <button class="control-btn" onclick="playAgain()">üîÑ Ch∆°i l·∫°i</button>
        </div>
    </div>

    <script>
        // Kh·ªüi t·∫°o b√†n c·ªù ban ƒë·∫ßu
        const initialBoard = [
            ['‚ôú','‚ôû','‚ôù','‚ôõ','‚ôö','‚ôù','‚ôû','‚ôú'],
            ['‚ôü','‚ôü','‚ôü','‚ôü','‚ôü','‚ôü','‚ôü','‚ôü'],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['‚ôô','‚ôô','‚ôô','‚ôô','‚ôô','‚ôô','‚ôô','‚ôô'],
            ['‚ôñ','‚ôò','‚ôó','‚ôï','‚ôî','‚ôó','‚ôò','‚ôñ']
        ];

        let board = JSON.parse(JSON.stringify(initialBoard));
        let currentPlayer = 'white';
        let selectedSquare = null;
        let gameMode = 'vs-human';
        let aiDifficulty = 2;
        let gameHistory = [];
        let gameOver = false;

        // √Ånh x·∫° qu√¢n c·ªù
        const pieceValues = {
            '‚ôî': 1000, '‚ôï': 9, '‚ôñ': 5, '‚ôó': 3, '‚ôò': 3, '‚ôô': 1,
            '‚ôö': -1000, '‚ôõ': -9, '‚ôú': -5, '‚ôù': -3, '‚ôû': -3, '‚ôü': -1,
            '': 0
        };

        function initGame() {
            createBoard();
            updateDisplay();
        }

        function createBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.addEventListener('click', handleSquareClick);
                    
                    const piece = document.createElement('span');
                    piece.className = 'piece';
                    piece.textContent = board[row][col];
                    square.appendChild(piece);
                    
                    chessboard.appendChild(square);
                }
            }
        }

        function handleSquareClick(event) {
            if (gameOver) return;
            if (gameMode === 'vs-ai' && currentPlayer === 'black') return;

            const row = parseInt(event.currentTarget.dataset.row);
            const col = parseInt(event.currentTarget.dataset.col);

            if (selectedSquare) {
                if (selectedSquare.row === row && selectedSquare.col === col) {
                    clearSelection();
                    return;
                }

                if (isValidMove(selectedSquare.row, selectedSquare.col, row, col)) {
                    makeMove(selectedSquare.row, selectedSquare.col, row, col);
                    clearSelection();
                    
                    if (gameMode === 'vs-ai' && currentPlayer === 'black' && !gameOver) {
                        setTimeout(makeAIMove, 500);
                    }
                } else {
                    clearSelection();
                    if (board[row][col] && isPlayerPiece(board[row][col], currentPlayer)) {
                        selectSquare(row, col);
                    }
                }
            } else {
                if (board[row][col] && isPlayerPiece(board[row][col], currentPlayer)) {
                    selectSquare(row, col);
                }
            }
        }

        function selectSquare(row, col) {
            selectedSquare = { row, col };
            updateDisplay();
            highlightPossibleMoves(row, col);
        }

        function clearSelection() {
            selectedSquare = null;
            updateDisplay();
        }

        function highlightPossibleMoves(row, col) {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                square.classList.remove('possible-move');
                const r = parseInt(square.dataset.row);
                const c = parseInt(square.dataset.col);
                if (isValidMove(row, col, r, c)) {
                    square.classList.add('possible-move');
                }
            });
        }

        function isPlayerPiece(piece, player) {
            const whitePieces = '‚ôî‚ôï‚ôñ‚ôó‚ôò‚ôô';
            const blackPieces = '‚ôö‚ôõ‚ôú‚ôù‚ôû‚ôü';
            return player === 'white' ? whitePieces.includes(piece) : blackPieces.includes(piece);
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;
            
            const piece = board[fromRow][fromCol];
            const targetPiece = board[toRow][toCol];
            
            if (!piece) return false;
            if (targetPiece && isPlayerPiece(targetPiece, currentPlayer)) return false;

            const rowDiff = toRow - fromRow;
            const colDiff = toCol - fromCol;

            switch (piece) {
                case '‚ôô': // T·ªët tr·∫Øng
                    if (colDiff === 0 && !targetPiece) {
                        if (rowDiff === -1) return true;
                        if (fromRow === 6 && rowDiff === -2) return true;
                    }
                    if (Math.abs(colDiff) === 1 && rowDiff === -1 && targetPiece) return true;
                    return false;

                case '‚ôü': // T·ªët ƒëen
                    if (colDiff === 0 && !targetPiece) {
                        if (rowDiff === 1) return true;
                        if (fromRow === 1 && rowDiff === 2) return true;
                    }
                    if (Math.abs(colDiff) === 1 && rowDiff === 1 && targetPiece) return true;
                    return false;

                case '‚ôñ': case '‚ôú': // Xe
                    if (rowDiff === 0 || colDiff === 0) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case '‚ôó': case '‚ôù': // T∆∞·ª£ng
                    if (Math.abs(rowDiff) === Math.abs(colDiff)) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case '‚ôï': case '‚ôõ': // H·∫≠u
                    if (rowDiff === 0 || colDiff === 0 || Math.abs(rowDiff) === Math.abs(colDiff)) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case '‚ôî': case '‚ôö': // Vua
                    return Math.abs(rowDiff) <= 1 && Math.abs(colDiff) <= 1;

                case '‚ôò': case '‚ôû': // M√£
                    return (Math.abs(rowDiff) === 2 && Math.abs(colDiff) === 1) ||
                           (Math.abs(rowDiff) === 1 && Math.abs(colDiff) === 2);

                default:
                    return false;
            }
        }

        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;

            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;

            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol] !== '') return false;
                currentRow += rowStep;
                currentCol += colStep;
            }

            return true;
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];

            gameHistory.push({
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol },
                piece: piece,
                capturedPiece: capturedPiece,
                board: JSON.parse(JSON.stringify(board))
            });

            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '';

            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            updateDisplay();
            checkGameEnd();
        }

        function makeAIMove() {
            if (gameOver) return;

            const bestMove = findBestMove();
            if (bestMove) {
                makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
            }
        }

        function findBestMove() {
            let bestMove = null;
            let bestValue = Infinity;

            const moves = getAllPossibleMoves('black');
            
            for (let move of moves) {
                const tempBoard = JSON.parse(JSON.stringify(board));
                board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                board[move.fromRow][move.fromCol] = '';

                let value;
                if (aiDifficulty === 1) {
                    // Ch·∫ø ƒë·ªô d·ªÖ - AI ch∆°i ng·∫´u nhi√™n v√† ƒë√¥i khi m·∫Øc l·ªói
                    value = Math.random() * 20 - 10; // Ch∆°i r·∫•t ng·∫´u nhi√™n
                } else if (aiDifficulty === 2) {
                    // Ch·∫ø ƒë·ªô trung b√¨nh - Minimax v·ªõi ƒë·ªô s√¢u 2
                    value = minimax(2, false, -Infinity, Infinity);
                } else {
                    // Ch·∫ø ƒë·ªô kh√≥ - Minimax v·ªõi ƒë·ªô s√¢u 4 + ƒë√°nh gi√° v·ªã tr√≠
                    value = minimax(4, false, -Infinity, Infinity) + evaluatePosition(move);
                }

                board = tempBoard;

                if (value < bestValue) {
                    bestValue = value;
                    bestMove = move;
                }
            }

            return bestMove;
        }

        function minimax(depth, isMaximizing, alpha, beta) {
            if (depth === 0) {
                return evaluateBoard();
            }

            const moves = getAllPossibleMoves(isMaximizing ? 'white' : 'black');
            
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let move of moves) {
                    const tempBoard = JSON.parse(JSON.stringify(board));
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = '';

                    const eval = minimax(depth - 1, false, alpha, beta);
                    board = tempBoard;

                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let move of moves) {
                    const tempBoard = JSON.parse(JSON.stringify(board));
                    board[move.toRow][move.toCol] = board[move.fromRow][move.fromCol];
                    board[move.fromRow][move.fromCol] = '';

                    const eval = minimax(depth - 1, true, alpha, beta);
                    board = tempBoard;

                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        function getAllPossibleMoves(player) {
            const moves = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && isPlayerPiece(piece, player)) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(row, col, toRow, toCol)) {
                                    moves.push({ fromRow: row, fromCol: col, toRow, toCol });
                                }
                            }
                        }
                    }
                }
            }
            return moves;
        }

        function evaluateBoard() {
            let score = 0;
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    const pieceValue = pieceValues[piece] || 0;
                    
                    // Th√™m ƒëi·ªÉm v·ªã tr√≠ cho c√°c qu√¢n c·ªù (ch·∫ø ƒë·ªô kh√≥)
                    if (aiDifficulty === 3 && piece) {
                        score += pieceValue + getPositionValue(piece, row, col);
                    } else {
                        score += pieceValue;
                    }
                }
            }
            return score;
        }

        function getPositionValue(piece, row, col) {
            const centerBonus = Math.max(0, 4 - Math.abs(3.5 - row) - Math.abs(3.5 - col)) * 0.1;
            
            switch (piece) {
                case '‚ôû': // M√£ ƒëen
                    return centerBonus * 3; // M√£ ·ªü gi·ªØa m·∫°nh h∆°n
                case '‚ôù': // T∆∞·ª£ng ƒëen
                    return centerBonus * 2;
                case '‚ôü': // T·ªët ƒëen
                    return (7 - row) * 0.1; // T·ªët ti·∫øn v·ªÅ ph√≠a tr∆∞·ªõc
                case '‚ôò': // M√£ tr·∫Øng
                    return -centerBonus * 3;
                case '‚ôó': // T∆∞·ª£ng tr·∫Øng
                    return -centerBonus * 2;
                case '‚ôô': // T·ªët tr·∫Øng
                    return -row * 0.1;
                default:
                    return centerBonus;
            }
        }

        function evaluatePosition(move) {
            if (aiDifficulty !== 3) return 0;
            
            let bonus = 0;
            const piece = board[move.fromRow][move.fromCol];
            const targetPiece = board[move.toRow][move.toCol];
            
            // Th∆∞·ªüng cho vi·ªác ƒÉn qu√¢n
            if (targetPiece) {
                bonus -= pieceValues[targetPiece] * 0.1;
            }
            
            // Th∆∞·ªüng cho vi·ªác ki·ªÉm so√°t trung t√¢m
            if (move.toRow >= 3 && move.toRow <= 4 && move.toCol >= 3 && move.toCol <= 4) {
                bonus -= 0.3;
            }
            
            // Th∆∞·ªüng cho vi·ªác ph√°t tri·ªÉn qu√¢n
            if (move.fromRow === 0 && (piece === '‚ôû' || piece === '‚ôù')) {
                bonus -= 0.2;
            }
            
            return bonus;
        }

        function checkGameEnd() {
            const whiteMoves = getAllPossibleMoves('white');
            const blackMoves = getAllPossibleMoves('black');

            if (whiteMoves.length === 0) {
                gameOver = true;
                if (gameMode === 'vs-human') {
                    document.getElementById('gameStatus').textContent = 'üèÜ Player 2 th·∫Øng!';
                } else {
                    document.getElementById('gameStatus').textContent = 'üèÜ M√°y th·∫Øng!';
                }
            } else if (blackMoves.length === 0) {
                gameOver = true;
                if (gameMode === 'vs-human') {
                    document.getElementById('gameStatus').textContent = 'üèÜ Player 1 th·∫Øng!';
                } else {
                    document.getElementById('gameStatus').textContent = 'üèÜ Ng∆∞·ªùi ch∆°i th·∫Øng!';
                }
            }
        }

        function updateDisplay() {
            const squares = document.querySelectorAll('.square');
            squares.forEach(square => {
                const row = parseInt(square.dataset.row);
                const col = parseInt(square.dataset.col);
                square.querySelector('.piece').textContent = board[row][col];
                
                square.classList.remove('selected', 'possible-move');
                if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
                    square.classList.add('selected');
                }
            });

            if (!gameOver) {
                document.getElementById('gameStatus').textContent = 
                    `L∆∞·ª£t c·ªßa qu√¢n ${currentPlayer === 'white' ? 'Tr·∫Øng' : 'ƒêen'}`;
            }
        }

        function setGameMode(mode) {
            gameMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            const difficultySelector = document.getElementById('difficultySelector');
            difficultySelector.style.display = mode === 'vs-ai' ? 'block' : 'none';
            
            newGame();
        }

        function setDifficulty() {
            aiDifficulty = parseInt(document.getElementById('difficulty').value);
        }

        function newGame() {
            board = JSON.parse(JSON.stringify(initialBoard));
            currentPlayer = 'white';
            selectedSquare = null;
            gameHistory = [];
            gameOver = false;
            updateDisplay();
        }

        function playAgain() {
            board = JSON.parse(JSON.stringify(initialBoard));
            currentPlayer = 'white';
            selectedSquare = null;
            gameHistory = [];
            gameOver = false;
            updateDisplay();
        }

        // Kh·ªüi t·∫°o game khi trang ƒë∆∞·ª£c t·∫£i
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
