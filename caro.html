<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caro Game</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f9f9f9;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        header h1 {
            color: #333;
            font-size: 2.5em;
            margin: 0;
        }
        header p {
            color: #666;
            font-size: 1em;
            margin-top: 5px;
        }
        .back-container {
            align-self: flex-start;
            margin-bottom: 20px;
        }
        .back-container a {
            text-decoration: none;
            color: #007bff;
            font-size: 1.2em;
            display: flex;
            align-items: center;
        }
        .back-container a i {
            margin-right: 5px;
        }
        .game-container {
            width: 80%;
            max-width: 600px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        .controls button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .controls button:hover {
            background-color: #0056b3;
        }
        .options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 15px;
        }
        .options div {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .options label {
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #333;
        }
        .options select, .options input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 0.9em;
            width: 100%;
            box-sizing: border-box;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(10, 40px);
            gap: 2px;
            justify-content: center;
        }
        .cell {
            width: 40px;
            height: 40px;
            background: #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.2s ease;
        }
        .cell.X {
            color: #007bff;
        }
        .cell.O {
            color: #dc3545;
        }
        .cell:hover {
            background-color: #d1e7dd;
        }
        .message {
            text-align: center;
            margin-top: 15px;
            font-size: 1.2em;
            color: #28a745;
        }
        footer {
            margin-top: 20px;
            font-size: 0.9em;
            color: #666;
        }
        @media (max-width: 600px) {
            h2 {
                font-size: 1.5rem;
            }
            .back-container {
                padding: 6px 10px;
            }
            .back-container a {
                font-size: 0.8rem;
            }
            .controls {
                flex-direction: column;
            }
            button {
                flex: none;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="back-container">
        <a href="game.html">
            <i class="fas fa-arrow-left"></i> Quay lại
        </a>
    </div>
    <header>
        <h1>Caro Game</h1>
        <p id="game-mode">Chế độ chơi: Chưa chọn</p>
    </header>
    <div class="game-container">
        <div class="controls">
            <button onclick="startGame('computer')">Chơi với máy</button>
            <button onclick="startGame('player')">Chơi với người</button>
            <button onclick="resetBoard()">Chơi lại</button>
        </div>
        <div class="options">
            <div>
                <label>Độ khó:</label>
                <select id="difficulty" onchange="setDifficulty(this.value)">
                    <option value="easy">Dễ</option>
                    <option value="medium">Trung bình</option>
                    <option value="hard">Khó</option>
                    <option value="very-hard">Siêu khó</option>
                    <option value="extreme">Cực khó</option>
                </select>
            </div>
            <div>
                <label>Số ô để thắng:</label>
                <input type="number" id="winCondition" value="5" min="3" max="7">
            </div>
        </div>
        <div class="board" id="board"></div>
        <div class="message" id="message"></div>
    </div>
    <script>
        const boardSize = 10;
        let boardState = Array(boardSize).fill(null).map(() => Array(boardSize).fill(null));
        let currentPlayer = 'O';
        const computerPlayer = 'O';
        const humanPlayer = 'X';
        let difficultyLevel = 'medium';
        let winConditionLength = 5;
        let currentGameMoves = [];
        let currentMode = null;

        const boardElement = document.getElementById('board');
        const messageElement = document.getElementById('message');
        const gameModeElement = document.getElementById('game-mode');
        const winConditionInput = document.getElementById('winCondition');

        function startGame(mode) {
            resetBoardWithoutStart();
            currentMode = mode;
            if (mode === 'computer') {
                gameModeElement.textContent = `Chế độ chơi: Player (X) vs Máy (O, đi trước)`;
                currentPlayer = computerPlayer;
                makeComputerMove(true); // Gọi nước đi đầu tiên không delay
            } else {
                gameModeElement.textContent = `Chế độ chơi: Player 1 vs Player 2`;
                currentPlayer = 'X';
            }
        }

        function resetBoard() {
            resetBoardWithoutStart();
            if (currentMode) {
                startGame(currentMode); // Tự động bắt đầu lại trò chơi với chế độ hiện tại
            }
        }

        function resetBoardWithoutStart() {
            boardState = Array(boardSize).fill(null).map(() => Array(boardSize).fill(null));
            boardElement.innerHTML = '';
            messageElement.textContent = '';
            currentGameMoves = [];
            for (let i = 0; i < boardSize * boardSize; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.addEventListener('click', () => handleCellClick(i));
                boardElement.appendChild(cell);
            }
        }

        function setDifficulty(level) {
            difficultyLevel = level;
        }

        function handleCellClick(index) {
            if (boardState[Math.floor(index / boardSize)][index % boardSize] || currentPlayer === computerPlayer) return;

            placePiece(index, humanPlayer);

            if (checkWin(humanPlayer)) {
                showMessage(`${humanPlayer} thắng!`);
                return;
            }

            if (!boardState.flat().includes(null)) {
                showMessage('Hòa!');
                return;
            }

            currentPlayer = computerPlayer;
            makeComputerMove();
        }

        function placePiece(index, player) {
            const row = Math.floor(index / boardSize);
            const col = index % boardSize;
            boardState[row][col] = player;
            boardElement.children[index].textContent = player;
            boardElement.children[index].classList.add(player);
            currentGameMoves.push({ row, col, player });
        }

        function checkWin(player) {
            winConditionLength = parseInt(winConditionInput.value, 10);
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (boardState[row][col] === player) {
                        for (const { rowDir, colDir } of directions) {
                            let count = 1;
                            for (let i = 1; i < winConditionLength; i++) {
                                const newRow = row + i * rowDir;
                                const newCol = col + i * colDir;
                                if (newRow >= boardSize || newCol >= boardSize || boardState[newRow][newCol] !== player) break;
                                count++;
                            }
                            if (count === winConditionLength) {
                                highlightWinningLine(row, col, rowDir, colDir, player);
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function highlightWinningLine(row, col, rowDir, colDir, player) {
            for (let i = 0; i < winConditionLength; i++) {
                const index = (row + i * rowDir) * boardSize + (col + i * colDir);
                boardElement.children[index].style.backgroundColor = player === 'X' ? '#d1e7dd' : '#f8d7da';
            }
        }

        function showMessage(msg) {
            messageElement.textContent = msg;
            if (msg.includes('thắng') || msg === 'Hòa!') {
                saveGameResult(msg.includes('X') ? 'X' : msg.includes('O') ? 'O' : 'tie');
            }
        }

        function makeComputerMove(noDelay = false) {
            const executeMove = async () => {
                let move;
                switch (difficultyLevel) {
                    case 'easy': move = getEasyMove(); break;
                    case 'medium': move = getMediumMove(); break;
                    case 'hard': move = await getHardMove(); break;
                    case 'very-hard': move = await getVeryHardMove(); break;
                    case 'extreme': move = await getExtremeMove(); break;
                    default: move = getMediumMove();
                }
                if (move) {
                    placePiece(move.row * boardSize + move.col, computerPlayer);
                    if (checkWin(computerPlayer)) {
                        showMessage(`${computerPlayer} thắng!`);
                        return;
                    }
                    if (!boardState.flat().includes(null)) {
                        showMessage('Hòa!');
                        return;
                    }
                    currentPlayer = humanPlayer;
                }
            };

            if (noDelay) {
                executeMove(); // Thực hiện ngay lập tức khi bắt đầu hoặc chơi lại
            } else {
                setTimeout(executeMove, 100); // Delay cho các nước đi sau trong ván chơi
            }
        }

        function getEasyMove() {
            const moves = getPotentialMoves();
            return moves[Math.floor(Math.random() * moves.length)];
        }

        function getMediumMove() {
            return findWinningMove(computerPlayer) || findWinningMove(humanPlayer) || getEasyMove();
        }

        async function getHardMove() {
            return findWinningMove(computerPlayer) || 
                   findWinningMove(humanPlayer) || 
                   blockTwoInARow(humanPlayer) || 
                   createThreat(computerPlayer) || 
                   await runAlphaBeta(computerPlayer, 2) || 
                   getEasyMove();
        }

        async function getVeryHardMove() {
            return findWinningMove(computerPlayer) || 
                   findWinningMove(humanPlayer) || 
                   blockTwoInARow(humanPlayer) || 
                   createThreat(computerPlayer) || 
                   await runAlphaBeta(computerPlayer, 3) || 
                   getEasyMove();
        }

        async function getExtremeMove() {
            return findWinningMove(computerPlayer) || 
                   findWinningMove(humanPlayer) || 
                   blockTwoInARow(humanPlayer) || 
                   createThreat(computerPlayer) || 
                   await runAlphaBeta(computerPlayer, 4) || 
                   getEasyMove();
        }

        function getPotentialMoves() {
            const moves = [];
            const range = 2;
            for (const { row, col } of currentGameMoves) {
                for (let r = Math.max(0, row - range); r <= Math.min(boardSize - 1, row + range); r++) {
                    for (let c = Math.max(0, col - range); c <= Math.min(boardSize - 1, col + range); c++) {
                        if (!boardState[r][c]) moves.push({ row: r, col: c });
                    }
                }
            }
            return moves.length ? moves : [{ row: Math.floor(boardSize / 2), col: Math.floor(boardSize / 2) }];
        }

        function findWinningMove(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                if (checkWin(player)) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        function blockTwoInARow(player) {
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];
            for (const { row, col } of currentGameMoves) {
                if (boardState[row][col] === player) {
                    for (const dir of directions) {
                        const nextRow = row + dir.rowDir;
                        const nextCol = col + dir.colDir;
                        if (nextRow >= 0 && nextRow < boardSize && nextCol >= 0 && nextCol < boardSize &&
                            boardState[nextRow][nextCol] === player) {
                            const blockRow = nextRow + dir.rowDir;
                            const blockCol = nextCol + dir.colDir;
                            if (blockRow >= 0 && blockRow < boardSize && blockCol >= 0 && blockCol < boardSize &&
                                !boardState[blockRow][blockCol]) {
                                return { row: blockRow, col: blockCol };
                            }
                            const prevRow = row - dir.rowDir;
                            const prevCol = col - dir.colDir;
                            if (prevRow >= 0 && prevRow < boardSize && prevCol >= 0 && prevCol < boardSize &&
                                !boardState[prevRow][prevCol]) {
                                return { row: prevRow, col: prevCol };
                            }
                        }
                    }
                }
            }
            return null;
        }

        function createThreat(player) {
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];
            for (const { row, col } of getPotentialMoves()) {
                for (const dir of directions) {
                    let count = 0;
                    let emptyCount = 0;
                    for (let i = 1; i <= 4; i++) {
                        const newRow = row + i * dir.rowDir;
                        const newCol = col + i * dir.colDir;
                        if (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize) {
                            if (boardState[newRow][newCol] === player) count++;
                            else if (!boardState[newRow][newCol]) emptyCount++;
                            else break;
                        }
                    }
                    if (count >= 2 && emptyCount >= 1) return { row, col };
                }
            }
            return null;
        }

        async function runAlphaBeta(player, depth) {
            let XX, YY;
            alphabeta(player, -Infinity, Infinity, depth, (row, col) => {
                XX = row;
                YY = col;
            });
            return (XX !== undefined && YY !== undefined) ? { row: XX, col: YY } : null;
        }

        function alphabeta(XO, alpha, beta, depth, setBestMove) {
            if (checkWin('X')) return XO === 'X' ? -Infinity : Infinity;
            if (checkWin('O')) return XO === 'O' ? Infinity : -Infinity;
            if (depth === 0 || !boardState.flat().includes(null)) return evaluateBoard();

            const moves = getPotentialMoves();
            moves.sort((a, b) => evaluateBoardMove(a.row, a.col, XO) - evaluateBoardMove(b.row, b.col, XO));
            let bestMove = null;

            if (XO === computerPlayer) {
                for (const move of moves) {
                    boardState[move.row][move.col] = XO;
                    const score = alphabeta(humanPlayer, alpha, beta, depth - 1, setBestMove);
                    boardState[move.row][move.col] = null;
                    if (score > alpha) {
                        alpha = score;
                        bestMove = move;
                    }
                    if (alpha >= beta) break;
                }
                if ((depth === 2 || depth === 3 || depth === 4) && bestMove) setBestMove(bestMove.row, bestMove.col);
                return alpha;
            } else {
                for (const move of moves) {
                    boardState[move.row][move.col] = XO;
                    const score = alphabeta(computerPlayer, alpha, beta, depth - 1, setBestMove);
                    boardState[move.row][move.col] = null;
                    if (score < beta) beta = score;
                    if (alpha >= beta) break;
                }
                return beta;
            }
        }

        function evaluateBoardMove(row, col, player) {
            boardState[row][col] = player;
            const score = evaluateBoard();
            boardState[row][col] = null;
            return score;
        }

        function evaluateBoard() {
            let score = 0;
            const patterns = [
                { pattern: /OOOOO/g, score: 100000 },
                { pattern: /XXXXX/g, score: -100000 },
                { pattern: /0OOOO0/g, score: 1000 },
                { pattern: /0XXXX0/g, score: -1000 },
                { pattern: /0OOO0/g, score: 100 },
                { pattern: /0XXX0/g, score: -100 }
            ];
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];

            for (const dir of directions) {
                for (const { row, col } of currentGameMoves) {
                    let boardStr = '';
                    for (let i = -winConditionLength; i <= winConditionLength; i++) {
                        const r = row + i * dir.rowDir;
                        const c = col + i * dir.colDir;
                        if (r >= 0 && r < boardSize && c >= 0 && c < boardSize) {
                            boardStr += boardState[r][c] || '0';
                        }
                    }
                    for (const { pattern, score: patternScore } of patterns) {
                        score += (boardStr.match(pattern) || []).length * patternScore;
                    }
                }
            }
            return score;
        }

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open("CaroAI_DB", 1);
                request.onupgradeneeded = event => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains("matches")) {
                        db.createObjectStore("matches", { keyPath: "id", autoIncrement: true });
                    }
                };
                request.onsuccess = event => resolve(event.target.result);
                request.onerror = event => reject(event.target.error);
            });
        }

        async function saveMatchData(gameData) {
            const db = await openDB();
            const transaction = db.transaction("matches", "readwrite");
            transaction.objectStore("matches").add(gameData);
        }

        async function getPastMatches(limit = 10) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const request = db.transaction("matches", "readonly").objectStore("matches").getAll();
                request.onsuccess = () => resolve(request.result.slice(-limit));
                request.onerror = () => reject(request.error);
            });
        }

        async function saveGameResult(winner) {
            await saveMatchData({
                moves: currentGameMoves,
                winner: winner,
                timestamp: new Date().toISOString()
            });
        }

        async function analyzePastGames(limit = 10) {
            const pastGames = await getPastMatches(limit);
            const moveScores = new Map();
            pastGames.forEach(game => {
                game.moves.forEach(move => {
                    const key = `${move.row},${move.col}`;
                    if (!moveScores.has(key)) moveScores.set(key, { wins: 0, total: 0 });
                    const stats = moveScores.get(key);
                    stats.total++;
                    if (game.winner === move.player) stats.wins++;
                });
            });
            const bestMoves = [];
            moveScores.forEach((stats, key) => {
                const [row, col] = key.split(',').map(Number);
                const winRate = stats.wins / stats.total;
                if (stats.total > 1 && winRate > 0.5) bestMoves.push({ row, col, winRate });
            });
            return bestMoves.sort((a, b) => b.winRate - a.winRate);
        }
    </script>
    <footer>
        <div class="footer-container">
            <div class="social-icons">
                <a href="https://www.facebook.com/nguyenthanhsang70" target="_blank"><i class="fab fa-facebook-f"></i></a>
                <a href="https://www.instagram.com/ngth.sang70/" target="_blank"><i class="fab fa-instagram"></i></a>
                <a href="https://www.tiktok.com/@thanh.sang70" target="_blank"><i class="fab fa-tiktok"></i></a>
            </div>
            © 2025 NTS. Được thiết kế bởi <a href="https://www.facebook.com/nthanhsang70">Nguyễn Thanh Sang</a>.
        </div>
    </footer>
</body>
</html>
