<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caro Game</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f9f9f9;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
        }
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        header h1 {
            color: #333;
            font-size: 2.5em;
            margin: 0;
        }
        header p {
            color: #666;
            font-size: 1em;
            margin-top: 5px;
        }
        .back-container {
            align-self: flex-start;
            margin-bottom: 20px;
        }
        .back-container a {
            text-decoration: none;
            color: #007bff;
            font-size: 1.2em;
            display: flex;
            align-items: center;
        }
        .back-container a i {
            margin-right: 5px;
        }
        .game-container {
            width: 80%;
            max-width: 600px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        .controls button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .controls button:hover {
            background-color: #0056b3;
            transform: scale(1.05); /* Slight scale-up on hover */
        }
        .options {
            display: none; /* Hidden by default */
            background-color: #f8f9fa; /* Light background for distinction */
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin-bottom: 15px;
        }
        .options div {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .options label {
            margin-bottom: 8px;
            font-size: 1em;
            color: #2c3e50; /* Darker color for better contrast */
            font-weight: 500;
        }
        .options select {
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 1em;
            width: 100%;
            max-width: 200px; /* Limit width for better alignment */
            box-sizing: border-box;
            background-color: #fff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .options select:focus {
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
            outline: none;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(10, 40px);
            gap: 2px;
            justify-content: center;
        }
        .cell {
            width: 40px;
            height: 40px;
            background: #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.2s ease;
        }
        .cell.X {
            color: #007bff;
        }
        .cell.O {
            color: #dc3545;
        }
        .cell:hover {
            background-color: #d1e7dd;
        }
        .message {
            text-align: center;
            margin-top: 15px;
            font-size: 1.2em;
            color: #28a745;
        }
        .player-options {
            display: none; /* Hidden by default */
            margin-bottom: 15px;
            background-color: #f8f9fa; /* Light background for distinction */
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .player-options div {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 15px;
        }
        .player-options label {
            margin-bottom: 8px;
            font-size: 1em;
            color: #2c3e50; /* Darker color for better contrast */
            font-weight: 500;
        }
        .player-options select {
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 1em;
            width: 100%;
            max-width: 200px; /* Limit width for better alignment */
            box-sizing: border-box;
            background-color: #fff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .player-options select:focus {
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
            outline: none;
        }
        .player-options button {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            background-color: #28a745; /* Green for start button */
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .player-options button:hover {
            background-color: #218838;
            transform: scale(1.05); /* Slight scale-up on hover */
        }
        footer {
            margin-top: auto; /* Push footer to the bottom */
            width: 100%;
            background-color: #2c3e50; /* Darker background */
            color: #ecf0f1; /* Light text */
            padding: 20px 0;
            text-align: center;
            border-radius: 8px;
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
        }
        .footer-container {
            max-width: 600px;
            margin: 0 auto;
        }
        .social-icons {
            margin-bottom: 10px;
        }
        .social-icons a {
            color: #ecf0f1;
            font-size: 1.5em;
            margin: 0 15px;
            text-decoration: none;
            transition: color 0.3s ease, transform 0.3s ease;
        }
        .social-icons a:hover {
            color: #3498db; /* Bright blue on hover */
            transform: scale(1.2); /* Slight scale-up effect */
        }
        .footer-container p {
            margin: 0;
            font-size: 0.9em;
        }
        .footer-container a {
            color: #3498db; /* Matching blue for the link */
            text-decoration: none;
            font-weight: bold;
            transition: color 0.3s ease;
        }
        .footer-container a:hover {
            color: #ecf0f1; /* Light text on hover */
        }
        @media (max-width: 600px) {
            .board {
                grid-template-columns: repeat(10, 30px); /* Giảm kích thước ô */
                gap: 1px; /* Giảm khoảng cách giữa các ô */
            }
            .cell {
                width: 30px; /* Giảm kích thước ô */
                height: 30px;
                font-size: 1.2em; /* Giảm kích thước font chữ */
            }
            .game-container {
                width: 100%; /* Chiếm toàn bộ chiều rộng màn hình */
                padding: 10px; /* Giảm padding */
            }
            .controls button {
                padding: 8px 12px; /* Giảm padding của nút */
                font-size: 0.9em; /* Giảm kích thước font chữ của nút */
            }
            .options select, .player-options select {
                max-width: 100%; /* Đảm bảo dropdown chiếm toàn bộ chiều rộng */
                font-size: 0.9em; /* Giảm kích thước font chữ của dropdown */
            }
            .message {
                font-size: 1em; /* Giảm kích thước font chữ của thông báo */
            }
        }
    </style>
</head>
<body>
    <div class="back-container">
        <a href="game.html">
            <i class="fas fa-arrow-left"></i> Quay lại
        </a>
    </div>
    <header>
        <h1>Caro Game</h1>
        <p id="game-mode">Chế độ chơi: Chưa chọn</p>
    </header>
    <div class="game-container">
        <div class="controls">
            <button onclick="startGame('computer')">Chơi với máy</button>
            <button onclick="showPlayerOptions()">Chơi với người</button>
            <button onclick="resetBoard()">Chơi lại</button>
        </div>
        <div class="options" id="difficultyOptions">
            <div>
                <label>Độ khó:</label>
                <select id="difficulty" onchange="setDifficulty(this.value)">
                    <option value="easy">Dễ</option>
                    <option value="medium">Trung bình</option>
                    <option value="hard">Khó</option>
                </select>
            </div>
        </div>
        <div class="player-options" id="playerOptions">
            <div>
                <label>Chọn quân cho Player 1:</label>
                <select id="player1Piece" onchange="setPlayerPieces()">
                    <option value="X">X</option>
                    <option value="O">O</option>
                </select>
            </div>
            <div>
                <label>Chọn quân cho Player 2:</label>
                <select id="player2Piece" onchange="setPlayerPieces()">
                    <option value="O">O</option>
                    <option value="X">X</option>
                </select>
            </div>
            <div>
                <label>Số ô để thắng:</label>
                <select id="winLength" onchange="setWinLength(this.value)">
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </div>
            <button onclick="startPlayerGame()">Bắt đầu chơi</button>
        </div>
        <div class="board" id="board"></div>
        <div class="message" id="message"></div>
    </div>
    <script>
        const boardSize = 10;
        let boardState = Array(boardSize).fill(null).map(() => Array(boardSize).fill(null));
        let currentPlayer = 'X'; // Default for player mode
        let computerPlayer = 'O';
        let humanPlayer = 'X'; // Player 1
        let player2Piece = 'O'; // Player 2
        let difficultyLevel = 'medium';
        let winConditionLength = 5; // Default set to 5 for consistency with traps
        let currentGameMoves = [];
        let currentMode = null;

        const boardElement = document.getElementById('board');
        const messageElement = document.getElementById('message');
        const gameModeElement = document.getElementById('game-mode');
        const playerOptionsElement = document.getElementById('playerOptions');
        const difficultyOptionsElement = document.getElementById('difficultyOptions');
        const player1PieceSelect = document.getElementById('player1Piece');
        const player2PieceSelect = document.getElementById('player2Piece');

        function showPlayerOptions() {
            playerOptionsElement.style.display = 'block';
            difficultyOptionsElement.style.display = 'none';
            gameModeElement.textContent = `Chế độ chơi: Đang chọn tùy chỉnh cho Player 1 vs Player 2`;
        }

        function setPlayerPieces() {
            const player1Choice = player1PieceSelect.value;
            const player2Choice = player2PieceSelect.value;

            if (player1Choice === player2Choice) {
                player2PieceSelect.value = player1Choice === 'X' ? 'O' : 'X';
            }

            humanPlayer = player1Choice;
            player2Piece = player2PieceSelect.value;
            currentPlayer = humanPlayer;
            computerPlayer = 'O';
        }

        function setWinLength(length) {
            winConditionLength = parseInt(length);
        }

        function startPlayerGame() {
            resetBoardWithoutStart();
            currentMode = 'player';
            gameModeElement.textContent = `Chế độ chơi: Player 1 (${humanPlayer}) vs Player 2 (${player2Piece})`;
            playerOptionsElement.style.display = 'none';
            difficultyOptionsElement.style.display = 'none';
        }

        function startGame(mode) {
            resetBoardWithoutStart();
            currentMode = mode;
            if (mode === 'computer') {
                gameModeElement.textContent = `Chế độ chơi: Người chơi (X) vs Máy (O, đi trước)`;
                currentPlayer = computerPlayer;
                humanPlayer = 'X';
                computerPlayer = 'O';
                winConditionLength = 5; // Ensure consistency with traps
                difficultyOptionsElement.style.display = 'block';
                playerOptionsElement.style.display = 'none';
                makeComputerMove(true);
            }
        }

        function resetBoard() {
            if (currentMode === 'computer') {
                resetBoardWithoutStart();
                startGame('computer');
            } else if (currentMode === 'player') {
                resetBoardWithoutStart();
                currentPlayer = humanPlayer;
                gameModeElement.textContent = `Chế độ chơi: Player 1 (${humanPlayer}) vs Player 2 (${player2Piece})`;
            } else {
                resetBoardWithoutStart();
                difficultyOptionsElement.style.display = 'none';
                playerOptionsElement.style.display = 'none';
                gameModeElement.textContent = `Chế độ chơi: Chưa chọn`;
            }
        }

        function resetBoardWithoutStart() {
            boardState = Array(boardSize).fill(null).map(() => Array(boardSize).fill(null));
            boardElement.innerHTML = '';
            messageElement.textContent = '';
            currentGameMoves = [];
            for (let i = 0; i < boardSize * boardSize; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.addEventListener('click', () => handleCellClick(i));
                boardElement.appendChild(cell);
            }
        }

        function setDifficulty(level) {
            difficultyLevel = level;
        }

        function handleCellClick(index) {
            if (boardState[Math.floor(index / boardSize)][index % boardSize] || (currentMode === 'computer' && currentPlayer === computerPlayer)) return;

            placePiece(index, currentMode === 'computer' ? humanPlayer : currentPlayer);

            if (checkWin(currentMode === 'computer' ? humanPlayer : currentPlayer)) {
                showMessage(currentMode === 'computer' ? (humanPlayer === currentPlayer ? 'Người chơi thắng!' : 'Máy thắng!') : (currentPlayer === humanPlayer ? 'Player 1 thắng!' : 'Player 2 thắng!'));
                return;
            }

            if (!boardState.flat().includes(null)) {
                showMessage('Hòa!');
                return;
            }

            if (currentMode === 'computer') {
                currentPlayer = computerPlayer;
                makeComputerMove();
            } else {
                currentPlayer = currentPlayer === humanPlayer ? player2Piece : humanPlayer;
            }
        }

        function placePiece(index, player) {
            const row = Math.floor(index / boardSize);
            const col = index % boardSize;
            boardState[row][col] = player;
            boardElement.children[index].textContent = player;
            boardElement.children[index].classList.add(player);
            currentGameMoves.push({ row, col, player });
        }

        function checkWin(player) {
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (boardState[row][col] === player) {
                        for (const { rowDir, colDir } of directions) {
                            let count = 1;
                            for (let i = 1; i < winConditionLength; i++) {
                                const newRow = row + i * rowDir;
                                const newCol = col + i * colDir;
                                if (newRow >= boardSize || newCol >= boardSize || newRow < 0 || newCol < 0 || boardState[newRow][newCol] !== player) break;
                                count++;
                            }
                            if (count === winConditionLength) {
                                highlightWinningLine(row, col, rowDir, colDir, player);
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function highlightWinningLine(row, col, rowDir, colDir, player) {
            for (let i = 0; i < winConditionLength; i++) {
                const index = (row + i * rowDir) * boardSize + (col + i * colDir);
                boardElement.children[index].style.backgroundColor = '#d1e7dd'; // Light green for winning line
            }
        }

        function showMessage(msg) {
            if (msg.includes('thắng')) {
                if (currentMode === 'computer') {
                    msg = currentPlayer === 'X' ? 'Người chơi thắng!' : 'Máy thắng!';
                } else {
                    msg = currentPlayer === humanPlayer ? 'Player 1 thắng!' : 'Player 2 thắng!';
                }
            }
            messageElement.textContent = msg;
            if (msg.includes('thắng') || msg === 'Hòa!') {
                saveGameResult(msg.includes(humanPlayer) ? humanPlayer : msg.includes(player2Piece) ? player2Piece : 'tie');
            }
        }

        function makeComputerMove(noDelay = false) {
            const executeMove = async () => {
                let move;
                switch (difficultyLevel) {
                    case 'easy': move = getEasyMove(); break;
                    case 'medium': move = getMediumMove(); break;
                    case 'hard': move = await getHardMove(); break;
                    default: move = getMediumMove();
                }
                if (move) {
                    placePiece(move.row * boardSize + move.col, computerPlayer);
                    if (checkWin(computerPlayer)) {
                        showMessage('Máy thắng!');
                        return;
                    }
                    if (!boardState.flat().includes(null)) {
                        showMessage('Hòa!');
                        return;
                    }
                    currentPlayer = humanPlayer;
                }
            };

            if (noDelay) {
                executeMove();
            } else {
                setTimeout(executeMove, 100);
            }
        }

        function getEasyMove() {
            const moves = getPotentialMoves();
            return moves[Math.floor(Math.random() * moves.length)];
        }

        function getMediumMove() {
            return findWinningMove(computerPlayer) || findWinningMove(humanPlayer) || getEasyMove();
        }

        async function getHardMove() {
            const moves = getPotentialMoves();
            const remainingCells = boardState.flat().filter(cell => !cell).length;

            // Priority 1: Win immediately
            const winningMove = findWinningMove(computerPlayer);
            if (winningMove) return winningMove;

            // Priority 2: Block opponent's win
            const blockWin = findWinningMove(humanPlayer);
            if (blockWin) return blockWin;

            // Priority 3: Block opponent's Open Four
            const blockOpenFour = findOpenFour(humanPlayer);
            if (blockOpenFour) return blockOpenFour;

            // Priority 4: Create Open Four
            const openFourAttack = findOpenFour(computerPlayer);
            if (openFourAttack) return openFourAttack;

            // Priority 5: Block opponent's Half-Open Four
            const blockHalfOpenFour = findHalfOpenFour(humanPlayer);
            if (blockHalfOpenFour) return blockHalfOpenFour;

            // Priority 6: New Traps (21-36)
            const interruptedHorizontalTrap = createInterruptedHorizontalTrap(computerPlayer); // Bẫy "Hàng Ngang Gián Đoạn"
            if (interruptedHorizontalTrap) return interruptedHorizontalTrap;

            const doubleOpenDiagonalTrap = createDoubleOpenDiagonalTrap(computerPlayer); // Bẫy "Hai Đầu Mở Kết Hợp Chéo"
            if (doubleOpenDiagonalTrap) return doubleOpenDiagonalTrap;

            const misleadDirectionTrap = createMisleadDirectionTrap(computerPlayer); // Bẫy "Dụ Đối Thủ Đi Lệch Hướng"
            if (misleadDirectionTrap && remainingCells > boardSize * boardSize * 0.5) return misleadDirectionTrap;

            const tripleParallelTrap = createTripleParallelTrap(computerPlayer); // Bẫy "Tạo 3 Đường Song Song"
            if (tripleParallelTrap) return tripleParallelTrap;

            const lShapeTrap = createLShapeTrap(computerPlayer); // Bẫy "Hình Chữ L"
            if (lShapeTrap) return lShapeTrap;

            const squareTrap = createSquareTrap(computerPlayer); // Bẫy "Hình Vuông"
            if (squareTrap) return squareTrap;

            const blurBlockTrap = createBlurBlockTrap(computerPlayer); // Bẫy "Làm Mờ Đường Chắn"
            if (blurBlockTrap) return blurBlockTrap;

            const twoMiddleGapsTrap = createTwoMiddleGapsTrap(computerPlayer); // Bẫy "Tạo 2 Ô Trống Ở Giữa"
            if (twoMiddleGapsTrap) return twoMiddleGapsTrap;

            const baitThreeTrap = createBaitThreeTrap(computerPlayer); // Bẫy "Đánh Nhử 3 Quân"
            if (baitThreeTrap && remainingCells > boardSize * boardSize * 0.5) return baitThreeTrap;

            const hShapeTrap = createHShapeTrap(computerPlayer); // Bẫy "Chữ H"
            if (hShapeTrap) return hShapeTrap;

            const wrongDirectionTrap = createWrongDirectionTrap(computerPlayer); // Bẫy "Chặn Sai Hướng"
            if (wrongDirectionTrap && remainingCells > boardSize * boardSize * 0.5) return wrongDirectionTrap;

            const wallTrap = createWallTrap(computerPlayer); // Bẫy "Xây Dựng Tường"
            if (wallTrap) return wallTrap;

            const useOpponentPieceTrap = createUseOpponentPieceTrap(computerPlayer); // Bẫy "Lợi Dụng Quân Của Đối Thủ"
            if (useOpponentPieceTrap) return useOpponentPieceTrap;

            const hiddenFourTrap = createHiddenFourTrap(computerPlayer); // Bẫy "Tạo 4 Quân Ẩn"
            if (hiddenFourTrap) return hiddenFourTrap;

            const fenceTrap = createFenceTrap(computerPlayer); // Bẫy "Lập Hàng Rào"
            if (fenceTrap) return fenceTrap;

            const tripleDiagonalComboTrap = createTripleDiagonalComboTrap(computerPlayer); // Bẫy "Tạo 3 Đường Chéo Kết Hợp"
            if (tripleDiagonalComboTrap) return tripleDiagonalComboTrap;

            // Priority 7: Create Half-Open Four
            const halfOpenFourAttack = findHalfOpenFour(computerPlayer);
            if (halfOpenFourAttack) return halfOpenFourAttack;

            // Priority 8: Block opponent's Open Three
            const blockOpenThree = findOpenThree(humanPlayer);
            if (blockOpenThree) return blockOpenThree;

            // Priority 9: Create Open Three
            const openThreeAttack = findOpenThree(computerPlayer);
            if (openThreeAttack) return openThreeAttack;

            // Priority 10: Block opponent's Half-Open Three
            const blockHalfOpenThree = findHalfOpenThree(humanPlayer);
            if (blockHalfOpenThree) return blockHalfOpenThree;

            // Priority 11: Active Defense
            const activeDefense = blockMultipleThreeInARow(humanPlayer);
            if (activeDefense) return activeDefense;

            // Priority 12: Occupy Center (early game)
            if (remainingCells > boardSize * boardSize * 0.8) {
                const centerMove = occupyCenter();
                if (centerMove) return centerMove;
            }

            // Priority 13: Create Open Two
            const openTwoAttack = findOpenTwo(computerPlayer);
            if (openTwoAttack) return openTwoAttack;

            // Priority 14: Endgame Strategy
            if (remainingCells < boardSize * boardSize * 0.2) {
                const endgameMove = await runAlphaBeta(computerPlayer, 6);
                if (endgameMove) return endgameMove;
            }

            // Fallback: Alpha-Beta or Random
            return await runAlphaBeta(computerPlayer, 4) || getEasyMove();
        }

        function getPotentialMoves() {
            const moves = [];
            const range = 2;
            for (const { row, col } of currentGameMoves) {
                for (let r = Math.max(0, row - range); r <= Math.min(boardSize - 1, row + range); r++) {
                    for (let c = Math.max(0, col - range); c <= Math.min(boardSize - 1, col + range); c++) {
                        if (!boardState[r][c]) moves.push({ row: r, col: c });
                    }
                }
            }
            return moves.length ? moves : [{ row: Math.floor(boardSize / 2), col: Math.floor(boardSize / 2) }];
        }

        function findWinningMove(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                if (checkWin(player)) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        function findOpenFour(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                if (countLine(row, col, player, 4, true)) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        function findHalfOpenFour(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                if (countLine(row, col, player, 4, false)) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        function findOpenThree(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                if (countLine(row, col, player, 3, true)) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        function findHalfOpenThree(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                if (countLine(row, col, player, 3, false)) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        function findOpenTwo(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                if (countLine(row, col, player, 2, true)) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        function countLine(row, col, player, length, requireOpenEnds) {
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];
            for (const { rowDir, colDir } of directions) {
                let count = 1;
                let openEnds = 0;

                for (let i = 1; i < length; i++) {
                    const newRow = row + i * rowDir;
                    const newCol = col + i * colDir;
                    if (newRow >= boardSize || newCol >= boardSize || newRow < 0 || newCol < 0 || boardState[newRow][newCol] !== player) break;
                    count++;
                }
                const forwardRow = row + length * rowDir;
                const forwardCol = col + length * colDir;
                if (forwardRow >= 0 && forwardRow < boardSize && forwardCol >= 0 && forwardCol < boardSize && !boardState[forwardRow][forwardCol]) openEnds++;

                for (let i = 1; i < length; i++) {
                    const newRow = row - i * rowDir;
                    const newCol = col - i * colDir;
                    if (newRow < 0 || newCol < 0 || newRow >= boardSize || newCol >= boardSize || boardState[newRow][newCol] !== player) break;
                    count++;
                }
                const backwardRow = row - length * rowDir;
                const backwardCol = col - length * colDir;
                if (backwardRow >= 0 && backwardRow < boardSize && backwardCol >= 0 && backwardCol < boardSize && !boardState[backwardRow][backwardCol]) openEnds++;

                if (count >= length && (!requireOpenEnds || openEnds === 2)) return true;
            }
            return false;
        }

        // Trap 21: Bẫy "Hàng Ngang Gián Đoạn"
        function createInterruptedHorizontalTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let count = 1, gaps = 0;
                for (let i = 1; i <= 4; i++) {
                    const newCol = col + i;
                    if (newCol < boardSize) {
                        if (boardState[row][newCol] === player) count++;
                        else if (!boardState[row][newCol]) gaps++;
                        else break;
                    }
                }
                for (let i = 1; i <= 4; i++) {
                    const newCol = col - i;
                    if (newCol >= 0) {
                        if (boardState[row][newCol] === player) count++;
                        else if (!boardState[row][newCol]) gaps++;
                        else break;
                    }
                }
                if (count === 4 && gaps === 1) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 22: Bẫy "Hai Đầu Mở Kết Hợp Chéo"
        function createDoubleOpenDiagonalTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                if (countLine(row, col, player, 4, true)) {
                    for (const { rowDir, colDir } of [{ rowDir: 1, colDir: 1 }, { rowDir: 1, colDir: -1 }]) {
                        let count = 1;
                        for (let i = 1; i < winConditionLength; i++) {
                            const newRow = row + i * rowDir;
                            const newCol = col + i * colDir;
                            if (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize && boardState[newRow][newCol] === player) count++;
                        }
                        if (count >= 3) {
                            boardState[row][col] = null;
                            return { row, col };
                        }
                    }
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 23: Bẫy "Dụ Đối Thủ Đi Lệch Hướng"
        function createMisleadDirectionTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                const fakeLine = countLine(row, col, player, 4, false);
                if (fakeLine) {
                    for (const { row: r, col: c } of getPotentialMoves()) {
                        if (r !== row || c !== col) {
                            boardState[r][c] = player;
                            if (checkWin(player)) {
                                boardState[r][c] = null;
                                boardState[row][col] = null;
                                return { row, col };
                            }
                            boardState[r][c] = null;
                        }
                    }
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 24: Bẫy "Tạo 3 Đường Song Song"
        function createTripleParallelTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let parallelCount = 0;
                for (let offset = -2; offset <= 2; offset += 2) {
                    const checkRow = row + offset;
                    if (checkRow >= 0 && checkRow < boardSize) {
                        let count = 1;
                        for (let i = 1; i < winConditionLength; i++) {
                            const newCol = col + i;
                            if (newCol < boardSize && boardState[checkRow][newCol] === player) count++;
                        }
                        if (count >= 3) parallelCount++;
                    }
                }
                if (parallelCount >= 3) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 25: Bẫy "Hình Chữ L"
        function createLShapeTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let lShape = false;
                if (row + 2 < boardSize && col + 2 < boardSize) {
                    if (boardState[row][col + 1] === player && boardState[row][col + 2] === player &&
                        boardState[row + 1][col + 2] === player) {
                        lShape = true;
                    }
                }
                if (lShape) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 26: Bẫy "Hình Vuông"
        function createSquareTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let square = false;
                if (row + 1 < boardSize && col + 1 < boardSize) {
                    if (boardState[row][col + 1] === player && boardState[row + 1][col] === player &&
                        boardState[row + 1][col + 1] === player) {
                        square = true;
                    }
                }
                if (square) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 27: Bẫy "Làm Mờ Đường Chắn"
        function createBlurBlockTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let threats = 0;
                for (const { rowDir, colDir } of [{ rowDir: 0, colDir: 1 }, { rowDir: 1, colDir: 0 }, { rowDir: 1, colDir: 1 }]) {
                    let count = 1;
                    for (let i = 1; i < 4; i++) {
                        const newRow = row + i * rowDir;
                        const newCol = col + i * colDir;
                        if (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize && boardState[newRow][newCol] === player) count++;
                    }
                    if (count >= 3) threats++;
                }
                if (threats >= 2) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 28: Bẫy "Tạo 2 Ô Trống Ở Giữa"
        function createTwoMiddleGapsTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let count = 1, gaps = 0;
                for (let i = 1; i <= 5; i++) {
                    const newCol = col + i;
                    if (newCol < boardSize) {
                        if (boardState[row][newCol] === player) count++;
                        else if (!boardState[row][newCol]) gaps++;
                        else break;
                    }
                }
                for (let i = 1; i <= 5; i++) {
                    const newCol = col - i;
                    if (newCol >= 0) {
                        if (boardState[row][newCol] === player) count++;
                        else if (!boardState[row][newCol]) gaps++;
                        else break;
                    }
                }
                if (count === 3 && gaps === 2) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 29: Bẫy "Đánh Nhử 3 Quân"
        function createBaitThreeTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                const fakeLine = countLine(row, col, player, 3, false);
                if (fakeLine) {
                    for (const { row: r, col: c } of getPotentialMoves()) {
                        if (r !== row || c !== col) {
                            boardState[r][c] = player;
                            if (checkWin(player)) {
                                boardState[r][c] = null;
                                boardState[row][col] = null;
                                return { row, col };
                            }
                            boardState[r][c] = null;
                        }
                    }
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 30: Bẫy "Chữ H"
        function createHShapeTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let hShape = false;
                if (row + 2 < boardSize && col + 2 < boardSize) {
                    if (boardState[row][col + 1] === player && boardState[row + 2][col + 1] === player &&
                        boardState[row + 1][col] === player && boardState[row + 1][col + 2] === player) {
                        hShape = true;
                    }
                }
                if (hShape) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 31: Bẫy "Chặn Sai Hướng"
        function createWrongDirectionTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                const fakeLine = countLine(row, col, player, 4, false);
                if (fakeLine) {
                    for (const { row: r, col: c } of getPotentialMoves()) {
                        if (r !== row || c !== col) {
                            boardState[r][c] = player;
                            if (checkWin(player)) {
                                boardState[r][c] = null;
                                boardState[row][col] = null;
                                return { row, col };
                            }
                            boardState[r][c] = null;
                        }
                    }
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 32: Bẫy "Xây Dựng Tường"
        function createWallTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let wallCount = 0;
                for (let offset = -2; offset <= 2; offset += 2) {
                    const checkRow = row + offset;
                    if (checkRow >= 0 && checkRow < boardSize) {
                        let count = 1;
                        for (let i = 1; i < winConditionLength; i++) {
                            const newCol = col + i;
                            if (newCol < boardSize && boardState[checkRow][newCol] === player) count++;
                        }
                        if (count >= 4) wallCount++;
                    }
                }
                if (wallCount >= 2) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 33: Bẫy "Lợi Dụng Quân Của Đối Thủ"
        function createUseOpponentPieceTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let count = 1;
                for (let i = 1; i < winConditionLength; i++) {
                    const newCol = col + i;
                    if (newCol < boardSize) {
                        if (boardState[row][newCol] === player || boardState[row][newCol] === humanPlayer) count++;
                        else break;
                    }
                }
                for (let i = 1; i < winConditionLength; i++) {
                    const newCol = col - i;
                    if (newCol >= 0) {
                        if (boardState[row][newCol] === player || boardState[row][newCol] === humanPlayer) count++;
                        else break;
                    }
                }
                if (count >= 5) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 34: Bẫy "Tạo 4 Quân Ẩn"
        function createHiddenFourTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let count = 1, gaps = 0;
                for (let i = 1; i <= 4; i++) {
                    const newCol = col + i;
                    if (newCol < boardSize) {
                        if (boardState[row][newCol] === player) count++;
                        else if (!boardState[row][newCol]) gaps++;
                        else break;
                    }
                }
                for (let i = 1; i <= 4; i++) {
                    const newCol = col - i;
                    if (newCol >= 0) {
                        if (boardState[row][newCol] === player) count++;
                        else if (!boardState[row][newCol]) gaps++;
                        else break;
                    }
                }
                if (count === 4 && gaps <= 1) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 35: Bẫy "Lập Hàng Rào"
        function createFenceTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let fenceCount = 0;
                for (let offset = -2; offset <= 2; offset += 2) {
                    const checkRow = row + offset;
                    if (checkRow >= 0 && checkRow < boardSize) {
                        let count = 1;
                        for (let i = 1; i < winConditionLength; i++) {
                            const newCol = col + i;
                            if (newCol < boardSize && boardState[checkRow][newCol] === player) count++;
                        }
                        if (count >= 4) fenceCount++;
                    }
                }
                if (fenceCount >= 2) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        // Trap 36: Bẫy "Tạo 3 Đường Chéo Kết Hợp"
        function createTripleDiagonalComboTrap(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let diagonalCount = 0;
                for (const { rowDir, colDir } of [{ rowDir: 1, colDir: 1 }, { rowDir: 1, colDir: -1 }]) {
                    let count = 1;
                    for (let i = 1; i < winConditionLength; i++) {
                        const newRow = row + i * rowDir;
                        const newCol = col + i * colDir;
                        if (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize && boardState[newRow][newCol] === player) count++;
                    }
                    if (count >= 3) diagonalCount++;
                }
                if (diagonalCount >= 3) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        function blockMultipleThreeInARow(player) {
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];
            let threats = [];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (boardState[row][col] === player) {
                        for (const dir of directions) {
                            let count = 1;
                            let startRow = row, startCol = col;
                            for (let i = 1; i < winConditionLength; i++) {
                                const newRow = row + i * dir.rowDir;
                                const newCol = col + i * dir.colDir;
                                if (newRow >= boardSize || newCol >= boardSize || newRow < 0 || newCol < 0 || boardState[newRow][newCol] !== player) break;
                                count++;
                                startRow = newRow;
                                startCol = newCol;
                            }
                            if (count >= 3) {
                                const blockForwardRow = startRow + dir.rowDir;
                                const blockForwardCol = startCol + dir.colDir;
                                const blockBackwardRow = row - dir.rowDir;
                                const blockBackwardCol = col - dir.colDir;
                                if (blockForwardRow >= 0 && blockForwardRow < boardSize && 
                                    blockForwardCol >= 0 && blockForwardCol < boardSize && 
                                    !boardState[blockForwardRow][blockForwardCol]) {
                                    threats.push({ row: blockForwardRow, col: blockForwardCol });
                                }
                                if (blockBackwardRow >= 0 && blockBackwardRow < boardSize && 
                                    blockBackwardCol >= 0 && blockBackwardCol < boardSize && 
                                    !boardState[blockBackwardRow][blockBackwardCol]) {
                                    threats.push({ row: blockBackwardRow, col: blockBackwardCol });
                                }
                            }
                        }
                    }
                }
            }
            if (threats.length > 0) {
                const threatCount = new Map();
                threats.forEach(threat => {
                    const key = `${threat.row},${threat.col}`;
                    threatCount.set(key, (threatCount.get(key) || 0) + 1);
                });
                let bestThreat = null;
                let maxCount = 0;
                threatCount.forEach((count, key) => {
                    if (count > maxCount) {
                        maxCount = count;
                        const [row, col] = key.split(',').map(Number);
                        bestThreat = { row, col };
                    }
                });
                return bestThreat;
            }
            return null;
        }

        function occupyCenter() {
            const center = Math.floor(boardSize / 2);
            if (!boardState[center][center]) return { row: center, col: center };
            return null;
        }

        async function runAlphaBeta(player, depth) {
            let XX, YY;
            alphabeta(player, -Infinity, Infinity, depth, (row, col) => {
                XX = row;
                YY = col;
            });
            return (XX !== undefined && YY !== undefined) ? { row: XX, col: YY } : null;
        }

        function alphabeta(XO, alpha, beta, depth, setBestMove) {
            if (checkWin(computerPlayer)) return XO === computerPlayer ? Infinity : -Infinity;
            if (checkWin(humanPlayer)) return XO === humanPlayer ? -Infinity : Infinity;
            if (depth === 0 || !boardState.flat().includes(null)) return evaluateBoard();

            const moves = getPotentialMoves();
            moves.sort((a, b) => evaluateBoardMove(b.row, b.col, XO) - evaluateBoardMove(a.row, a.col, XO));
            let bestMove = null;

            if (XO === computerPlayer) {
                for (const move of moves) {
                    boardState[move.row][move.col] = XO;
                    const score = alphabeta(humanPlayer, alpha, beta, depth - 1, setBestMove);
                    boardState[move.row][move.col] = null;
                    if (score > alpha) {
                        alpha = score;
                        bestMove = move;
                    }
                    if (alpha >= beta) break;
                }
                if (depth === Math.max(4, depth) && bestMove) setBestMove(bestMove.row, bestMove.col);
                return alpha;
            } else {
                for (const move of moves) {
                    boardState[move.row][move.col] = XO;
                    const score = alphabeta(computerPlayer, alpha, beta, depth - 1, setBestMove);
                    boardState[move.row][move.col] = null;
                    if (score < beta) {
                        beta = score;
                    }
                    if (alpha >= beta) break;
                }
                return beta;
            }
        }

        function evaluateBoardMove(row, col, player) {
            boardState[row][col] = player;
            const score = evaluateBoard();
            boardState[row][col] = null;
            return score;
        }

        function evaluateBoard() {
            let score = 0;
            const patterns = [
                { pattern: new RegExp(`${computerPlayer.repeat(winConditionLength)}`), score: 1000000 },
                { pattern: new RegExp(`${humanPlayer.repeat(winConditionLength)}`), score: -1000000 },
                { pattern: new RegExp(`0${computerPlayer.repeat(4)}0`), score: 100000 },
                { pattern: new RegExp(`0${humanPlayer.repeat(4)}0`), score: -100000 },
                { pattern: new RegExp(`0${computerPlayer.repeat(3)}0`), score: 10000 },
                { pattern: new RegExp(`0${humanPlayer.repeat(3)}0`), score: -10000 },
                { pattern: new RegExp(`0${computerPlayer.repeat(2)}0`), score: 1000 },
                { pattern: new RegExp(`0${humanPlayer.repeat(2)}0`), score: -1000 }
            ];
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];

            for (const dir of directions) {
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        let boardStr = '';
                        for (let i = -winConditionLength; i <= winConditionLength; i++) {
                            const r = row + i * dir.rowDir;
                            const c = col + i * dir.colDir;
                            if (r >= 0 && r < boardSize && c >= 0 && c < boardSize) {
                                boardStr += boardState[r][c] || '0';
                            }
                        }
                        for (const { pattern, score: patternScore } of patterns) {
                            score += (boardStr.match(pattern) || []).length * patternScore;
                        }
                    }
                }
            }
            return score;
        }

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open("CaroAI_DB", 1);
                request.onupgradeneeded = event => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains("matches")) {
                        db.createObjectStore("matches", { keyPath: "id", autoIncrement: true });
                    }
                };
                request.onsuccess = event => resolve(event.target.result);
                request.onerror = event => reject(event.target.error);
            });
        }

        async function saveMatchData(gameData) {
            const db = await openDB();
            const transaction = db.transaction("matches", "readwrite");
            transaction.objectStore("matches").add(gameData);
        }

        async function getPastMatches(limit = 10) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const request = db.transaction("matches", "readonly").objectStore("matches").getAll();
                request.onsuccess = () => resolve(request.result.slice(-limit));
                request.onerror = () => reject(request.error);
            });
        }

        async function saveGameResult(winner) {
            await saveMatchData({
                moves: currentGameMoves,
                winner: winner,
                timestamp: new Date().toISOString()
            });
        }

        async function analyzePastGames(limit = 10) {
            const pastGames = await getPastMatches(limit);
            const moveScores = new Map();
            pastGames.forEach(game => {
                game.moves.forEach(move => {
                    const key = `${move.row},${move.col}`;
                    if (!moveScores.has(key)) moveScores.set(key, { wins: 0, total: 0 });
                    const stats = moveScores.get(key);
                    stats.total++;
                    if (game.winner === move.player) stats.wins++;
                });
            });
            const bestMoves = [];
            moveScores.forEach((stats, key) => {
                const [row, col] = key.split(',').map(Number);
                const winRate = stats.wins / stats.total;
                if (stats.total > 1 && winRate > 0.5) bestMoves.push({ row, col, winRate });
            });
            return bestMoves.sort((a, b) => b.winRate - a.winRate);
        }
    </script>
    <footer>
        <div class="footer-container">
            <div class="social-icons">
                <a href="https://www.facebook.com/nguyenthanhsang70" target="_blank"><i class="fab fa-facebook-f"></i></a>
                <a href="https://www.instagram.com/ngth.sang70/" target="_blank"><i class="fab fa-instagram"></i></a>
                <a href="https://www.tiktok.com/@thanh.sang70" target="_blank"><i class="fab fa-tiktok"></i></a>
            </div>
            <p>© 2025 NTS. Được thiết kế bởi <a href="https://www.facebook.com/nthanhsang70">Nguyễn Thanh Sang</a>.</p>
        </div>
    </footer>
</body>
</html>
