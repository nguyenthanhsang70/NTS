<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Caro Game</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f9f9f9;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
        }
        header {
            text-align: center;
            margin-bottom: 20px;
        }
        header h1 {
            color: #333;
            font-size: 2.5em;
            margin: 0;
        }
        header p {
            color: #666;
            font-size: 1em;
            margin-top: 5px;
        }
        .back-container {
            align-self: flex-start;
            margin-bottom: 20px;
        }
        .back-container a {
            text-decoration: none;
            color: #007bff;
            font-size: 1.2em;
            display: flex;
            align-items: center;
        }
        .back-container a i {
            margin-right: 5px;
        }
        .game-container {
            width: 80%;
            max-width: 600px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        .controls button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .controls button:hover {
            background-color: #0056b3;
            transform: scale(1.05); /* Slight scale-up on hover */
        }
        .options {
            display: none; /* Hidden by default */
            background-color: #f8f9fa; /* Light background for distinction */
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            margin-bottom: 15px;
        }
        .options div {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .options label {
            margin-bottom: 8px;
            font-size: 1em;
            color: #2c3e50; /* Darker color for better contrast */
            font-weight: 500;
        }
        .options select {
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 1em;
            width: 100%;
            max-width: 200px; /* Limit width for better alignment */
            box-sizing: border-box;
            background-color: #fff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .options select:focus {
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
            outline: none;
        }
        .board {
            display: grid;
            grid-template-columns: repeat(10, 40px);
            gap: 2px;
            justify-content: center;
        }
        .cell {
            width: 40px;
            height: 40px;
            background: #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.2s ease;
        }
        .cell.X {
            color: #007bff;
        }
        .cell.O {
            color: #dc3545;
        }
        .cell:hover {
            background-color: #d1e7dd;
        }
        .message {
            text-align: center;
            margin-top: 15px;
            font-size: 1.2em;
            color: #28a745;
        }
        .player-options {
            display: none; /* Hidden by default */
            margin-bottom: 15px;
            background-color: #f8f9fa; /* Light background for distinction */
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .player-options div {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 15px;
        }
        .player-options label {
            margin-bottom: 8px;
            font-size: 1em;
            color: #2c3e50; /* Darker color for better contrast */
            font-weight: 500;
        }
        .player-options select {
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 1em;
            width: 100%;
            max-width: 200px; /* Limit width for better alignment */
            box-sizing: border-box;
            background-color: #fff;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .player-options select:focus {
            border-color: #007bff;
            box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
            outline: none;
        }
        .player-options button {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            background-color: #28a745; /* Green for start button */
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .player-options button:hover {
            background-color: #218838;
            transform: scale(1.05); /* Slight scale-up on hover */
        }
        footer {
            margin-top: auto; /* Push footer to the bottom */
            width: 100%;
            background-color: #2c3e50; /* Darker background */
            color: #ecf0f1; /* Light text */
            padding: 20px 0;
            text-align: center;
            border-radius: 8px;
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
        }
        .footer-container {
            max-width: 600px;
            margin: 0 auto;
        }
        .social-icons {
            margin-bottom: 10px;
        }
        .social-icons a {
            color: #ecf0f1;
            font-size: 1.5em;
            margin: 0 15px;
            text-decoration: none;
            transition: color 0.3s ease, transform 0.3s ease;
        }
        .social-icons a:hover {
            color: #3498db; /* Bright blue on hover */
            transform: scale(1.2); /* Slight scale-up effect */
        }
        .footer-container p {
            margin: 0;
            font-size: 0.9em;
        }
        .footer-container a {
            color: #3498db; /* Matching blue for the link */
            text-decoration: none;
            font-weight: bold;
            transition: color 0.3s ease;
        }
        .footer-container a:hover {
            color: #ecf0f1; /* Light text on hover */
        }
        @media (max-width: 600px) {
    .board {
        grid-template-columns: repeat(10, 30px); /* Giảm kích thước ô */
        gap: 1px; /* Giảm khoảng cách giữa các ô */
    }
    .cell {
        width: 30px; /* Giảm kích thước ô */
        height: 30px;
        font-size: 1.2em; /* Giảm kích thước font chữ */
    }
    .game-container {
        width: 100%; /* Chiếm toàn bộ chiều rộng màn hình */
        padding: 10px; /* Giảm padding */
    }
    .controls button {
        padding: 8px 12px; /* Giảm padding của nút */
        font-size: 0.9em; /* Giảm kích thước font chữ của nút */
    }
    .options select, .player-options select {
        max-width: 100%; /* Đảm bảo dropdown chiếm toàn bộ chiều rộng */
        font-size: 0.9em; /* Giảm kích thước font chữ của dropdown */
    }
    .message {
        font-size: 1em; /* Giảm kích thước font chữ của thông báo */
    }
}
    </style>
</head>
<body>
    <div class="back-container">
        <a href="game.html">
            <i class="fas fa-arrow-left"></i> Quay lại
        </a>
    </div>
    <header>
        <h1>Caro Game</h1>
        <p id="game-mode">Chế độ chơi: Chưa chọn</p>
    </header>
    <div class="game-container">
        <div class="controls">
            <button onclick="startGame('computer')">Chơi với máy</button>
            <button onclick="showPlayerOptions()">Chơi với người</button>
            <button onclick="resetBoard()">Chơi lại</button>
        </div>
        <div class="options" id="difficultyOptions">
            <div>
                <label>Độ khó:</label>
                <select id="difficulty" onchange="setDifficulty(this.value)">
                    <option value="easy">Dễ</option>
                    <option value="medium">Trung bình</option>
                    <option value="hard">Khó</option>
                </select>
            </div>
        </div>
        <div class="player-options" id="playerOptions">
            <div>
                <label>Chọn quân cho Player 1:</label>
                <select id="player1Piece" onchange="setPlayerPieces()">
                    <option value="X">X</option>
                    <option value="O">O</option>
                </select>
            </div>
            <div>
                <label>Chọn quân cho Player 2:</label>
                <select id="player2Piece" onchange="setPlayerPieces()">
                    <option value="O">O</option>
                    <option value="X">X</option>
                </select>
            </div>
            <div>
                <label>Số ô để thắng:</label>
                <select id="winLength" onchange="setWinLength(this.value)">
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </div>
            <button onclick="startPlayerGame()">Bắt đầu chơi</button>
        </div>
        <div class="board" id="board"></div>
        <div class="message" id="message"></div>
    </div>
    <script>
        const boardSize = 10;
        let boardState = Array(boardSize).fill(null).map(() => Array(boardSize).fill(null));
        let currentPlayer = 'X'; // Default for player mode
        let computerPlayer = 'O';
        let humanPlayer = 'X'; // Player 1
        let player2Piece = 'O'; // Player 2
        let difficultyLevel = 'medium';
        let winConditionLength = 3; // Default
        let currentGameMoves = [];
        let currentMode = null;

        const boardElement = document.getElementById('board');
        const messageElement = document.getElementById('message');
        const gameModeElement = document.getElementById('game-mode');
        const playerOptionsElement = document.getElementById('playerOptions');
        const difficultyOptionsElement = document.getElementById('difficultyOptions');
        const player1PieceSelect = document.getElementById('player1Piece');
        const player2PieceSelect = document.getElementById('player2Piece');

        function showPlayerOptions() {
            playerOptionsElement.style.display = 'block'; // Show player options
            difficultyOptionsElement.style.display = 'none'; // Hide difficulty options
            gameModeElement.textContent = `Chế độ chơi: Đang chọn tùy chỉnh cho Player 1 vs Player 2`;
        }

        function setPlayerPieces() {
            const player1Choice = player1PieceSelect.value;
            const player2Choice = player2PieceSelect.value;

            if (player1Choice === player2Choice) {
                // If both players choose the same piece, adjust Player 2's piece
                player2PieceSelect.value = player1Choice === 'X' ? 'O' : 'X';
            }

            humanPlayer = player1Choice; // Player 1
            player2Piece = player2PieceSelect.value; // Player 2
            currentPlayer = humanPlayer; // Player 1 starts
            computerPlayer = 'O'; // Default for computer mode, not used in player mode
        }

        function setWinLength(length) {
            winConditionLength = parseInt(length);
        }

        function startPlayerGame() {
            resetBoardWithoutStart();
            currentMode = 'player';
            gameModeElement.textContent = `Chế độ chơi: Player 1 (${humanPlayer}) vs Player 2 (${player2Piece})`;
            playerOptionsElement.style.display = 'none';
            difficultyOptionsElement.style.display = 'none'; // Ensure difficulty options are hidden
        }

        function startGame(mode) {
            resetBoardWithoutStart();
            currentMode = mode;
            if (mode === 'computer') {
                gameModeElement.textContent = `Chế độ chơi: Người chơi (X) vs Máy (O, đi trước)`;
                currentPlayer = computerPlayer;
                humanPlayer = 'X';
                computerPlayer = 'O';
                winConditionLength = 3; // Reset to default for computer mode
                difficultyOptionsElement.style.display = 'block'; // Show difficulty selection
                playerOptionsElement.style.display = 'none'; // Hide player options
                makeComputerMove(true);
            }
        }

        function resetBoard() {
            if (currentMode === 'computer') {
                resetBoardWithoutStart();
                startGame('computer'); // Reset and restart computer mode
            } else if (currentMode === 'player') {
                resetBoardWithoutStart(); // Reset board but keep player settings
                currentPlayer = humanPlayer; // Reset to Player 1's turn
                gameModeElement.textContent = `Chế độ chơi: Player 1 (${humanPlayer}) vs Player 2 (${player2Piece})`;
            } else {
                resetBoardWithoutStart();
                difficultyOptionsElement.style.display = 'none'; // Hide difficulty if no mode is active
                playerOptionsElement.style.display = 'none'; // Hide player options if no mode is active
                gameModeElement.textContent = `Chế độ chơi: Chưa chọn`;
            }
        }

        function resetBoardWithoutStart() {
            boardState = Array(boardSize).fill(null).map(() => Array(boardSize).fill(null));
            boardElement.innerHTML = '';
            messageElement.textContent = '';
            currentGameMoves = [];
            for (let i = 0; i < boardSize * boardSize; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.addEventListener('click', () => handleCellClick(i));
                boardElement.appendChild(cell);
            }
        }

        function setDifficulty(level) {
            difficultyLevel = level;
        }

        function handleCellClick(index) {
            if (boardState[Math.floor(index / boardSize)][index % boardSize] || (currentMode === 'computer' && currentPlayer === computerPlayer)) return;

            placePiece(index, currentMode === 'computer' ? humanPlayer : currentPlayer);

            if (checkWin(currentMode === 'computer' ? humanPlayer : currentPlayer)) {
                showMessage(currentMode === 'computer' ? (humanPlayer === currentPlayer ? 'Người chơi thắng!' : 'Máy thắng!') : (currentPlayer === humanPlayer ? 'Player 1 thắng!' : 'Player 2 thắng!'));
                return;
            }

            if (!boardState.flat().includes(null)) {
                showMessage('Hòa!');
                return;
            }

            if (currentMode === 'computer') {
                currentPlayer = computerPlayer;
                makeComputerMove();
            } else {
                currentPlayer = currentPlayer === humanPlayer ? player2Piece : humanPlayer;
            }
        }

        function placePiece(index, player) {
            const row = Math.floor(index / boardSize);
            const col = index % boardSize;
            boardState[row][col] = player;
            boardElement.children[index].textContent = player;
            boardElement.children[index].classList.add(player);
            currentGameMoves.push({ row, col, player });
        }

        function checkWin(player) {
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (boardState[row][col] === player) {
                        for (const { rowDir, colDir } of directions) {
                            let count = 1;
                            for (let i = 1; i < winConditionLength; i++) {
                                const newRow = row + i * rowDir;
                                const newCol = col + i * colDir;
                                if (newRow >= boardSize || newCol >= boardSize || boardState[newRow][newCol] !== player) break;
                                count++;
                            }
                            if (count === winConditionLength) {
                                highlightWinningLine(row, col, rowDir, colDir, player);
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function highlightWinningLine(row, col, rowDir, colDir, player) {
            for (let i = 0; i < winConditionLength; i++) {
                const index = (row + i * rowDir) * boardSize + (col + i * colDir);
                boardElement.children[index].style.backgroundColor = player === 'X' ? '#d1e7dd' : '#f8d7da';
            }
        }

        function showMessage(msg) {
            if (msg.includes('thắng')) {
                if (currentMode === 'computer') {
                    msg = msg.includes('X') ? 'Người chơi thắng!' : 'Máy thắng!';
                } else {
                    msg = currentPlayer === humanPlayer ? 'Player 1 thắng!' : 'Player 2 thắng!';
                }
            }
            messageElement.textContent = msg;
            if (msg.includes('thắng') || msg === 'Hòa!') {
                saveGameResult(msg.includes(humanPlayer) ? humanPlayer : msg.includes(player2Piece) ? player2Piece : 'tie');
            }
        }

        function makeComputerMove(noDelay = false) {
            const executeMove = async () => {
                let move;
                switch (difficultyLevel) {
                    case 'easy': move = getEasyMove(); break;
                    case 'medium': move = getMediumMove(); break;
                    case 'hard': move = await getHardMove(); break;
                    default: move = getMediumMove();
                }
                if (move) {
                    placePiece(move.row * boardSize + move.col, computerPlayer);
                    if (checkWin(computerPlayer)) {
                        showMessage('Máy thắng!');
                        return;
                    }
                    if (!boardState.flat().includes(null)) {
                        showMessage('Hòa!');
                        return;
                    }
                    currentPlayer = humanPlayer;
                }
            };

            if (noDelay) {
                executeMove();
            } else {
                setTimeout(executeMove, 100);
            }
        }

        function getEasyMove() {
            const moves = getPotentialMoves();
            return moves[Math.floor(Math.random() * moves.length)];
        }

        function getMediumMove() {
            return findWinningMove(computerPlayer) || findWinningMove(humanPlayer) || getEasyMove();
        }

        async function getHardMove() {
            return (
                findWinningMove(computerPlayer) ||
                findWinningMove(humanPlayer) ||
                blockMultipleThreeInARow(humanPlayer) ||
                createDoubleThreat(computerPlayer) ||
                blockTwoInARow(humanPlayer) ||
                createThreat(computerPlayer) ||
                await runAlphaBeta(computerPlayer, 3) ||
                getEasyMove()
            );
        }

        function getPotentialMoves() {
            const moves = [];
            const range = 2;
            for (const { row, col } of currentGameMoves) {
                for (let r = Math.max(0, row - range); r <= Math.min(boardSize - 1, row + range); r++) {
                    for (let c = Math.max(0, col - range); c <= Math.min(boardSize - 1, col + range); c++) {
                        if (!boardState[r][c]) moves.push({ row: r, col: c });
                    }
                }
            }
            return moves.length ? moves : [{ row: Math.floor(boardSize / 2), col: Math.floor(boardSize / 2) }];
        }

        function findWinningMove(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                if (checkWin(player)) {
                    boardState[row][col] = null;
                    return { row, col };
                }
                boardState[row][col] = null;
            }
            return null;
        }

        function blockMultipleThreeInARow(player) {
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];
            let threats = [];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (boardState[row][col] === player) {
                        for (const dir of directions) {
                            let count = 1;
                            let startRow = row, startCol = col;
                            for (let i = 1; i < winConditionLength; i++) {
                                const newRow = row + i * dir.rowDir;
                                const newCol = col + i * dir.colDir;
                                if (newRow >= boardSize || newCol >= boardSize || boardState[newRow][newCol] !== player) break;
                                count++;
                                startRow = newRow;
                                startCol = newCol;
                            }
                            if (count === winConditionLength) {
                                const blockForwardRow = startRow + dir.rowDir;
                                const blockForwardCol = startCol + dir.colDir;
                                const blockBackwardRow = row - dir.rowDir;
                                const blockBackwardCol = col - dir.colDir;
                                if (blockForwardRow >= 0 && blockForwardRow < boardSize && 
                                    blockForwardCol >= 0 && blockForwardCol < boardSize && 
                                    !boardState[blockForwardRow][blockForwardCol]) {
                                    threats.push({ row: blockForwardRow, col: blockForwardCol });
                                }
                                if (blockBackwardRow >= 0 && blockBackwardRow < boardSize && 
                                    blockBackwardCol >= 0 && blockBackwardCol < boardSize && 
                                    !boardState[blockBackwardRow][blockBackwardCol]) {
                                    threats.push({ row: blockBackwardRow, col: blockBackwardCol });
                                }
                            }
                        }
                    }
                }
            }
            if (threats.length > 0) {
                const threatCount = new Map();
                threats.forEach(threat => {
                    const key = `${threat.row},${threat.col}`;
                    threatCount.set(key, (threatCount.get(key) || 0) + 1);
                });
                let bestThreat = null;
                let maxCount = 0;
                threatCount.forEach((count, key) => {
                    if (count > maxCount) {
                        maxCount = count;
                        const [row, col] = key.split(',').map(Number);
                        bestThreat = { row, col };
                    }
                });
                return bestThreat;
            }
            return null;
        }

        function blockTwoInARow(player) {
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];
            for (const { row, col } of currentGameMoves) {
                if (boardState[row][col] === player) {
                    for (const dir of directions) {
                        const nextRow = row + dir.rowDir;
                        const nextCol = col + dir.colDir;
                        if (nextRow >= 0 && nextRow < boardSize && nextCol >= 0 && nextCol < boardSize &&
                            boardState[nextRow][nextCol] === player) {
                            const blockRow = nextRow + dir.rowDir;
                            const blockCol = nextCol + dir.colDir;
                            if (blockRow >= 0 && blockRow < boardSize && blockCol >= 0 && blockCol < boardSize &&
                                !boardState[blockRow][blockCol]) {
                                return { row: blockRow, col: blockCol };
                            }
                            const prevRow = row - dir.rowDir;
                            const prevCol = col - dir.colDir;
                            if (prevRow >= 0 && prevRow < boardSize && prevCol >= 0 && prevCol < boardSize &&
                                !boardState[prevRow][prevCol]) {
                                return { row: prevRow, col: prevCol };
                            }
                        }
                    }
                }
            }
            return null;
        }

        function createThreat(player) {
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];
            for (const { row, col } of getPotentialMoves()) {
                for (const dir of directions) {
                    let count = 0;
                    let emptyCount = 0;
                    for (let i = 1; i < winConditionLength; i++) {
                        const newRow = row + i * dir.rowDir;
                        const newCol = col + i * dir.colDir;
                        if (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize) {
                            if (boardState[newRow][newCol] === player) count++;
                            else if (!boardState[newRow][newCol]) emptyCount++;
                            else break;
                        }
                    }
                    if (count >= winConditionLength - 1 && emptyCount >= 1) return { row, col };
                }
            }
            return null;
        }

        function createDoubleThreat(player) {
            for (const { row, col } of getPotentialMoves()) {
                boardState[row][col] = player;
                let threatCount = 0;
                const directions = [
                    { rowDir: 0, colDir: 1 },
                    { rowDir: 1, colDir: 0 },
                    { rowDir: 1, colDir: 1 },
                    { rowDir: 1, colDir: -1 }
                ];
                for (const dir of directions) {
                    let count = 1;
                    let emptyCount = 0;
                    for (let i = 1; i < winConditionLength + 1; i++) {
                        const newRow = row + i * dir.rowDir;
                        const newCol = col + i * dir.colDir;
                        if (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize) {
                            if (boardState[newRow][newCol] === player) count++;
                            else if (!boardState[newRow][newCol]) emptyCount++;
                            else break;
                        }
                    }
                    if (count >= winConditionLength - 1 && emptyCount >= 1) threatCount++;
                }
                boardState[row][col] = null;
                if (threatCount >= 2) return { row, col };
            }
            return null;
        }

        async function runAlphaBeta(player, depth) {
            let XX, YY;
            alphabeta(player, -Infinity, Infinity, depth, (row, col) => {
                XX = row;
                YY = col;
            });
            return (XX !== undefined && YY !== undefined) ? { row: XX, col: YY } : null;
        }

        function alphabeta(XO, alpha, beta, depth, setBestMove) {
            if (checkWin('X')) return XO === 'X' ? -Infinity : Infinity;
            if (checkWin('O')) return XO === 'O' ? Infinity : -Infinity;
            if (depth === 0 || !boardState.flat().includes(null)) return evaluateBoard();

            const moves = getPotentialMoves();
            moves.sort((a, b) => evaluateBoardMove(a.row, a.col, XO) - evaluateBoardMove(b.row, b.col, XO));
            let bestMove = null;

            if (XO === computerPlayer) {
                for (const move of moves) {
                    boardState[move.row][move.col] = XO;
                    const score = alphabeta(humanPlayer, alpha, beta, depth - 1, setBestMove);
                    boardState[move.row][move.col] = null;
                    if (score > alpha) {
                        alpha = score;
                        bestMove = move;
                    }
                    if (alpha >= beta) break;
                }
                if (depth === 3 && bestMove) setBestMove(bestMove.row, bestMove.col);
                return alpha;
            } else {
                for (const move of moves) {
                    boardState[move.row][move.col] = XO;
                    const score = alphabeta(computerPlayer, alpha, beta, depth - 1, setBestMove);
                    boardState[move.row][move.col] = null;
                    if (score < beta) beta = score;
                    if (alpha >= beta) break;
                }
                return beta;
            }
        }

        function evaluateBoardMove(row, col, player) {
            boardState[row][col] = player;
            const score = evaluateBoard();
            boardState[row][col] = null;
            return score;
        }

        function evaluateBoard() {
            let score = 0;
            const patterns = [
                { pattern: new RegExp(`${computerPlayer.repeat(winConditionLength)}`), score: 100000 },
                { pattern: new RegExp(`${humanPlayer.repeat(winConditionLength)}`), score: -100000 },
                { pattern: new RegExp(`0${computerPlayer.repeat(winConditionLength - 1)}0`), score: 10000 },
                { pattern: new RegExp(`0${humanPlayer.repeat(winConditionLength - 1)}0`), score: -10000 },
                { pattern: new RegExp(`0${computerPlayer}0`), score: 1000 },
                { pattern: new RegExp(`0${humanPlayer}0`), score: -1000 },
                { pattern: new RegExp(`${computerPlayer.repeat(2)}0`), score: 500 },
                { pattern: new RegExp(`${humanPlayer.repeat(2)}0`), score: -500 }
            ];
            const directions = [
                { rowDir: 0, colDir: 1 },
                { rowDir: 1, colDir: 0 },
                { rowDir: 1, colDir: 1 },
                { rowDir: 1, colDir: -1 }
            ];

            for (const dir of directions) {
                for (const { row, col } of currentGameMoves) {
                    let boardStr = '';
                    for (let i = -winConditionLength; i <= winConditionLength; i++) {
                        const r = row + i * dir.rowDir;
                        const c = col + i * dir.colDir;
                        if (r >= 0 && r < boardSize && c >= 0 && c < boardSize) {
                            boardStr += boardState[r][c] || '0';
                        }
                    }
                    for (const { pattern, score: patternScore } of patterns) {
                        score += (boardStr.match(pattern) || []).length * patternScore;
                    }
                }
            }
            return score;
        }

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open("CaroAI_DB", 1);
                request.onupgradeneeded = event => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains("matches")) {
                        db.createObjectStore("matches", { keyPath: "id", autoIncrement: true });
                    }
                };
                request.onsuccess = event => resolve(event.target.result);
                request.onerror = event => reject(event.target.error);
            });
        }

        async function saveMatchData(gameData) {
            const db = await openDB();
            const transaction = db.transaction("matches", "readwrite");
            transaction.objectStore("matches").add(gameData);
        }

        async function getPastMatches(limit = 10) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const request = db.transaction("matches", "readonly").objectStore("matches").getAll();
                request.onsuccess = () => resolve(request.result.slice(-limit));
                request.onerror = () => reject(request.error);
            });
        }

        async function saveGameResult(winner) {
            await saveMatchData({
                moves: currentGameMoves,
                winner: winner,
                timestamp: new Date().toISOString()
            });
        }

        async function analyzePastGames(limit = 10) {
            const pastGames = await getPastMatches(limit);
            const moveScores = new Map();
            pastGames.forEach(game => {
                game.moves.forEach(move => {
                    const key = `${move.row},${move.col}`;
                    if (!moveScores.has(key)) moveScores.set(key, { wins: 0, total: 0 });
                    const stats = moveScores.get(key);
                    stats.total++;
                    if (game.winner === move.player) stats.wins++;
                });
            });
            const bestMoves = [];
            moveScores.forEach((stats, key) => {
                const [row, col] = key.split(',').map(Number);
                const winRate = stats.wins / stats.total;
                if (stats.total > 1 && winRate > 0.5) bestMoves.push({ row, col, winRate });
            });
            return bestMoves.sort((a, b) => b.winRate - a.winRate);
        }
    </script>
    <footer>
        <div class="footer-container">
            <div class="social-icons">
                <a href="https://www.facebook.com/nguyenthanhsang70" target="_blank"><i class="fab fa-facebook-f"></i></a>
                <a href="https://www.instagram.com/ngth.sang70/" target="_blank"><i class="fab fa-instagram"></i></a>
                <a href="https://www.tiktok.com/@thanh.sang70" target="_blank"><i class="fab fa-tiktok"></i></a>
            </div>
            <p>© 2025 NTS. Được thiết kế bởi <a href="https://www.facebook.com/nthanhsang70">Nguyễn Thanh Sang</a>.</p>
        </div>
    </footer>
</body>
</html>
